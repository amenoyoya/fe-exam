**CASL2 演習**
- プログラム:
    - 基準日（1970年1月1日）から、指定された日付までの日数を求める
    - 以下の各プログラムから戻る時、汎用レジスタ GR1〜GR7 の内容は元に戻す
- 副プログラム: `DAYOFFST`
    - 基準日から指定された日付までの日数を計算する
    - 日付は 汎用レジスタGR2 に設定されたアドレスから始まる連続した3語に 年, 月, 日 を表す数値として格納されている
    - 基準日を0日目として、指定された日付までの日数を、符号なし数値（0〜65535）として 汎用レジスタGR0 に設定して呼び出し元に戻る
- 副プログラム: `LEAPYEAR`
    - うるう年を判定する
    - GR2 に設定された年が平年の場合は0を、うるう年の場合は1を GR0 に設定して呼び出し元に戻る
    - うるう年判定:
        1. 年が4で割り切れない場合、平年
        2. 年が4で割り切れ、かつ100で割り切れない場合、うるう年
        3. 年が400で割り切れる場合、うるう年
        4. 上記のいずれでもない場合、平年
- 副プログラム: `DIVISIBL`
    - GR2 に設定された整数値が GR3 に設定された整数値で割り切れる場合は1を、割り切れない場合は0を GR0 に設定して呼び出し元に戻る

```
; メインプログラム
MAIN START
     ; GR1〜7の内容をスタックに退避
     CALL DAYOFFST ; 副プログラム DAYOFFST 呼び出し
     ; GR1〜7の内容をスタックから戻す
     RET ; 呼び出し元に戻る
     END

; 基準日から指定された日付までの日数を計算するプログラム
DAYOFFST START
         ; GR1〜7の内容をスタックに退避
         ; GR2から 年, 月, 日 をそれぞれ GR5, GR3, GR1 にロード
         ; <1月1日からの日数を求める（平年）>
         ; | 日 = 日 - 1
         ; | <日 + ACCMDAYS[月 - 1] を計算>
         ; | | GR4 = address(ACCMDAYS + 月)
         ; | | 日 = 日 + value(GR4-1)
         ; 3月以降ならうるう年を考慮
         ; | GR2 に 年 をセットして LEAPYEAR 呼び出し
         ; | うるう年なら 日 = 日 + 1
         ; <1970年〜(年-1)年までの日数を加算>
         ; | GR2 = 1970
         ; | GR2 < 年 ならループ
         ; | | LEAPYEAR 呼び出し
         ; | | 日 = 日 + 365 + GR0(LEAPYEARの戻り値)
         ; | | GR2 = GR2 + 1
         ; GR0 = 日
         ; GR1〜7の内容をスタックから戻す
         RET ; 呼び出し元に戻る
         END

; 平年の1月1日〜各月1日までの日数
; ACCMDAYS = [0,31,59,90,120,151,181,212,243,273,304,334]

; うるう年なら1を返すプログラム
LEAPYEAR START
         ; GR1〜7の内容をスタックに退避
         ; GR0 に戻り値 0（平年）を代入
         ; GR3 = GR2(年)
         ; GR3が4で割り切れないならプログラム終了
         ; GR3 = 100
         ; DIVISIBL 呼び出し: GR2(年) が GR3(100) で割り切れる？
         ; GR0(戻り値)が0（割り切れない）なら GR0 を 1（うるう年）に反転してプログラム終了
         ; GR3 = 400
         ; DIVISIBL 呼び出し: GR2(年) が GR3(400) で割り切れる？
         ; GR0(戻り値)が1（割り切れる）ならうるう年なので、GR0 はそのままで良い
         ; GR1〜7の内容をスタックから戻す
         RET ; 呼び出し元に戻る
         END

; GR2 が GR3 で割り切れるか判定するプログラム
DIVISIBL START
         ; GR1〜7の内容をスタックに退避
         ; GR0 に戻り値 0（割り切れない）を代入
         ; (GR2 = GR2 - GR3) > 0 ならループ
         ; | GR2 < 0 ならループを抜ける
         ; | GR2 = 0 なら GR0 に 1（割り切れる）を代入
         ; GR1〜7の内容をスタックから戻す
         RET ; 呼び出し元に戻る
         END
```